# 第1章

* スクリプトを AST 変換してからコンパイルするので時間がかかる
* Groovy2.3 から、@CompileStatic を付けて型を指定して速くすることができる
* Ruby との違い： Linux 環境と Windows 環境で書き方が変わらないのがいい

# 第2章

* IDE は？
	* IntelliJ IDEA
	* STS でもいいよ
* スクリプトをコンパイルして java コマンドで実行する時は main が要る？
* スクリプトファイルの名前がクラス名になるから、変えたい場合は必要
* AST 変換したソースコードは groovyConsole から見れる

# 第3章

## 3.1 assert

* assert は Java と違い例外が発生して止まる
* 例外 は catch しない限り全て上に raise されていく

## 3.2 ひとめぐり

* Groovy 2.3 から Java8 に対応したので、Stream API とシームレスに行き来が出来たりするので面白い
* as の別名にするのは、Kotlin とか Scala でも使えるし、他のライブラリで名前空間が衝突する際に避けるテクニックとしても使える

## 3.3 プログラムの構成

* マルチメソッドを持たない言語では、ダブルディスパッチというテクニックを使って、メソッド内部でレシーバを入れ替えて実行することで実行時の動的な型で実行されるように見せることができるが、Groovy だとそれが必要なく自然に動的なディスパッチができる
* GroovyBeans と lombok の組合せは、AST変換したソースコードを見ながら見てみればいいのでは
* Groovy はプロパティアクセス記法がメソッド呼び出しに代替される。明示的にフィールド参照したい場合は `.@` 演算子を使う

## 3.4 プロパティ、メソッド、フィールドの参照方法

* GString を使うと、文字列をメソッド名に指定することができるので、簡易なリフレクションのような形で動的にメソッドを呼ぶことができる
* Spock もこれを利用してテストコードを定義することが出来る

## 3.5 データ型

* メソッドの引数の型指定を `def` もしくは省略すると、`Object` で指定したことと同義になる
* Groovy では、ほとんどの場合プリミティブ型に対する操作はラッパークラスに変換されて処理されるため、他のオブジェクト型の操作と異なることなく操作できる。
* 演算子の操作はメソッド呼び出しのシンタックスシュガー
* 真偽値は `Boolean` 型へ変換され、空や0が `false` として判断される。`asBoolean()` メソッドで独自に定義することも出来る
* GString は内部的に式の評価結果を `Object` 型の配列として持っており、それらは `toString()` メソッド実行時にテンプレート文字列に展開される。そのため評価時によって値が変化するため、`HashMap` のキーなどに使うとハッシュが変化してしまうためトラブルの元となるため避ける。
* 逆に遅延評価を活かすには、immutable ではない変数で持ち回り（`List` や `Map`）、`asWriteble()` メソッドを使って取得したものを使うと、動的に時刻を表示することもできる。

## 3.6 クロージャ

## 3.7 コレクション型

## 3.8 演算子

* `as` 演算子は、Groovy 2.3 くらいから自動的にやってくれるようになった？
* `asType` メソッドは Groovy JDK の `Object` クラスに定義されているので、`as` 演算子で変換できる
* `<<` 演算子（`leftShift` メソッド）は、Gradle でよく見るパターンはクロージャの結果を左辺に適用する
    * 例えば dependencies に追加する際にある条件でフィルタしたい場合など

## 3.9 制御構造